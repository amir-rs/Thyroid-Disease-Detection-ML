# -*- coding: utf-8 -*-
"""Thyroid Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_MbEr9qw6fXcjVNr9Qw4OBpClZIsFIiG

#### **Objective Statement:**

The primary objective of this project is to leverage machine learning techniques to enhance the accuracy and efficiency of thyroid disorder detection. By employing advanced algorithms and data analytics, the goal is to develop a robust and reliable system capable of analyzing diverse medical data, including thyroid function tests and imaging results. The key focus is on creating a machine learning-based solution that can assist healthcare professionals in early and accurate identification of thyroid disorders, leading to timely interventions and improved patient outcomes.

**Thyroid Detection Dataset Overview:**

The Thyroid Detection dataset, sourced from the UCI Machine Learning Repository and made available on Kaggle, comprises 9172 observations with 31 attributes. The dataset is intended for the development and evaluation of machine learning models to detect thyroid disorders. Each observation represents a patient, and the attributes include demographic information, medical history, laboratory test results, and the target variable indicating the presence of hyperthyroidism.

**Key Attributes:**

1. **Demographic Information:**
   - *Age*: The age of the patient (integer).
   - *Sex*: Gender identification of the patient (string).

2. **Medical History:**
   - *On_thyroxine*: Boolean indicating whether the patient is on thyroxine.
   - *Query_on_thyroxine*: Boolean indicating queries regarding thyroxine usage.
   - *On_antithyroid_meds*: Boolean indicating whether the patient is on antithyroid medications.
   - *Sick*: Boolean indicating whether the patient is sick.
   - *Pregnant*: Boolean indicating whether the patient is pregnant.
   - *Thyroid_surgery*: Boolean indicating whether the patient has undergone thyroid surgery.
   - *I131_treatment*: Boolean indicating whether the patient is undergoing I131 treatment.
   - *Query_hypothyroid*: Boolean indicating the patient's belief of having hypothyroidism.
   - *Query_hyperthyroid*: Boolean indicating the patient's belief of having hyperthyroidism.
   - *Lithium*: Boolean indicating whether the patient uses lithium.
   - *Goitre*: Boolean indicating whether the patient has goitre.
   - *Tumor*: Boolean indicating whether the patient has a tumor.
   - *Hypopituitary*: Float value indicating a condition related to the hyperpituitary gland.
   - *Psych*: Boolean indicating a psychological condition.

3. **Laboratory Test Results:**
   - *TSH_measured*: Boolean indicating whether TSH was measured.
   - *TSH*: Float value representing the TSH level in the blood.
   - *T3_measured*: Boolean indicating whether T3 was measured.
   - *T3*: Float value representing the T3 level in the blood.
   - *TT4_measured*: Boolean indicating whether TT4 was measured.
   - *TT4*: Float value representing the TT4 level in the blood.
   - *T4U_measured*: Boolean indicating whether T4U was measured.
   - *T4U*: Float value representing the T4U level in the blood.
   - *FTI_measured*: Boolean indicating whether FTI was measured.
   - *FTI*: Float value representing the FTI level in the blood.
   - *TBG_measured*: Boolean indicating whether TBG was measured.
   - *TBG*: Float value representing the TBG level in the blood.

4. **Other Attributes:**
   - *Referral_source*: String indicating the source of patient referral.
   - *Target*: String indicating the medical diagnosis of hyperthyroidism.
   - *Patient_id*: String representing a unique identifier for each patient.

**Objective of Thyroid Detection:**

The primary goal of thyroid detection using this dataset is to develop machine learning models capable of accurately identifying patients with hyperthyroidism based on a combination of demographic information and laboratory test results. The models aim to assist healthcare professionals in early and precise diagnosis, leading to timely intervention and improved patient care. The dataset provides a comprehensive representation of patient profiles, making it a valuable resource for the development and evaluation of thyroid disorder detection algorithms.
"""

# Commented out IPython magic to ensure Python compatibility.
# Import Some Library
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns

import warnings
warnings.filterwarnings('ignore')

# Read CSV Data
data = pd.read_csv("/content/thyroidDF.csv")

data.head(10)

"""#### **Summary Of Data üïµÔ∏è‚Äç‚ôÇÔ∏è**

The Thyroid Detection dataset is a comprehensive collection of 9172 observations, each representing an individual patient, sourced from the UCI Machine Learning Repository and provided on Kaggle. This dataset is specifically curated for the development and evaluation of machine learning models focused on thyroid disorder detection, with a primary emphasis on hyperthyroidism.

**Key Characteristics:**

1. **Attributes Variety:**
   - The dataset encompasses a wide array of attributes, ranging from demographic details (age, sex) to medical history indicators (medication usage, surgeries, pregnancy) and crucial laboratory test results (TSH, T3, TT4, T4U, FTI).

2. **Boolean and Numeric Variables:**
   - Boolean variables are used to represent binary conditions (e.g., whether a patient is on medication, has undergone surgery, or if a specific test was measured).
   - Numeric variables include float values representing laboratory test results, providing quantitative insights into the patient's thyroid function.

3. **Target Variable:**
   - The dataset includes a target variable, "Target," which indicates the medical diagnosis of hyperthyroidism. This binary classification is crucial for training machine learning models to distinguish between individuals with and without hyperthyroidism.

4. **Patient Identifier:**
   - Each observation is associated with a unique patient identifier, enabling individualized tracking and analysis.

5. **Referral Source:**
   - The "Referral_source" attribute indicates the source from which the patient was referred, providing additional contextual information.
"""

# number of row's and col in data set
row,col=data.shape
print("Number of Row's in Data :",row)
print("Number of Col's in Data :",col)

# data duplicate
data.duplicated().sum()

data.info()

data.count()

data.describe()

"""#### **Data Cleaning üßπ**

"The Thyroid Detection dataset exhibits missing values in critical features such as 'sex,' 'TSH,' 'T3,' 'TT4,' 'T4U,' 'FTI,' and 'TBG.' To address this, imputation techniques were applied, replacing missing 'sex' values with the mode, and numeric values with their respective medians. Due to an extensive number of missing values in 'TBG' (8823 out of 9172), this column was dropped. The resulting dataset is now cleaned, allowing for robust analysis and machine learning model development, ensuring accurate detection of thyroid disorders."
"""

# missing data
data.isna().sum()

data.isnull().sum()

data['TBG_measured']

# whether TBG was measured in the blood
data['TBG_measured'].value_counts()

# drop TBG Column
data.drop(columns=['TBG','patient_id'],inplace=True)

# Randomly assign mean values to the some missing missing entries in the dataset
# 2604 Is missing entries in T3 column
Random_AVG_T3 = np.random.uniform(data['T3'].mean() - data['T3'].std(), data['T3'].mean() + data['T3'].std(), 2604)
# 809 Is missing entries in T4U column
Random_AVG_T4U = np.random.uniform(data['T4U'].mean() - data['T4U'].std(), data['T4U'].mean() + data['T4U'].std(), 809)
# 842 Is missing entries in TSH column
Random_AVG_TSH = np.random.uniform(data['TSH'].mean() - data['TSH'].std(), data['TSH'].mean() + data['TSH'].std(), 842)
# 442 Is missing entries in TT4 column
Random_AVG_TT4 = np.random.uniform(data['TT4'].mean() - data['TT4'].std(), data['TT4'].mean() + data['TT4'].std(), 442)
# 802 Is missing entries in FTI column
Random_AVG_FTI = np.random.uniform(data['FTI'].mean() - data['FTI'].std(), data['FTI'].mean() + data['FTI'].std(), 802)

# Insert Random value in dataset column T3
data['T3'][data['T3'].isnull()]=Random_AVG_T3

# Insert Random value in dataset column T4U
data['T4U'][data['T4U'].isnull()]=Random_AVG_T4U

# Insert Random value in dataset column T4U
data['TSH'][data['TSH'].isnull()]=Random_AVG_TSH

# Insert Random value in dataset column TT4
data['TT4'][data['TT4'].isnull()]=Random_AVG_TT4

# Insert Random value in dataset column FTI
data['FTI'][data['FTI'].isnull()]=Random_AVG_FTI

# drop missing Entites of sex (Because their one pregnant column also their )
data.dropna(inplace=True)

female,male=data['sex'].value_counts()

print('Total Male   : {}'.format(male))
print('Total Female : {}'.format(female))

# number of row's and col in data set
row,col=data.shape
print("Number of Row's in Data :",row)
print("Number of Col's in Data :",col)

# Different refferral sources
data['referral_source'].value_counts()

"""#### **Some Bool Column in dataset**
- **T : True**
- **F : False**
"""

# whether TBG was measured in the blood
data['TBG_measured'].value_counts()

# on_thyroxine - whether patient is on thyroxine
data['on_thyroxine'].value_counts()

# query on thyroxine - *whether patient is on thyroxine
data['query_on_thyroxine'].value_counts()

# on antithyroid meds - whether patient is on antithyroid meds
data['on_antithyroid_meds'].value_counts()

# sick - whether patient is sick
data['sick'].value_counts()

# pregnant - whether patient is pregnant
data['pregnant'].value_counts()

# thyroid_surgery - whether patient has undergone thyroid surgery
data['thyroid_surgery'].value_counts()

# I131_treatment - whether patient is undergoing I131 treatment
data['I131_treatment'].value_counts()

# query_hypothyroid - whether patient believes they have hypothyroid
data['query_hypothyroid'].value_counts()

# query_hyperthyroid - whether patient believes they have hyperthyroid
data['query_hyperthyroid'].value_counts()

# lithium - whether patient * lithium
data['lithium'].value_counts()

# goitre - whether patient has goitre
data['goitre'].value_counts()

# tumor - whether patient has tumor
data['tumor'].value_counts()

# psych - whether patient * psych
data['psych'].value_counts()

# T3_measured - whether T3 was measured in the blood
data['T3_measured'].value_counts()

# TT4_measured - whether TT4 was measured in the blood
data['TT4_measured'].value_counts()

# T4U_measured - whether T4U was measured in the blood
data['T4U_measured'].value_counts()

# FTI_measured - whether FTI was measured in the blood
data['FTI_measured'].value_counts()

data.describe(include='O').T

data.describe()

data['TSH'].head(200)

"""In the age data, an outlier is observed with a maximum value of 65526 years and a minimum value of 1 year. The presence of such extreme values suggests the possible existence of outliers in the dataset, and further investigation or data cleaning may be required to address these anomalies.

## **Detecting outliers**

### **Numerical Data**
- **if the data is following normal distribution, anything beyond 3SD mean 3SD can be considered as an outlier**
- **if the data does not follow normal distribution, using boxplot we can eliminate points beyond Q1 1.5 IQR and Q3 + 1.5 IQR**

### **Categorical data**
- **If the col is highly imbalanced for eg male 10000 and female 2 then we can eliminate female**
"""

# Handel Outliers of age column
data = data[data['age']<(data['age'].mean() + 3*data['age'].std())]
data = data[data['TSH']<(data['TSH'].mean() + 3*data['TSH'].std())]
data = data[data['T3']<(data['T3'].mean() + 3*data['T3'].std())]
data = data[data['TT4']<(data['TT4'].mean() + 3*data['TT4'].std())]
data = data[data['T4U']<(data['T4U'].mean() + 3*data['T4U'].std())]
data = data[data['FTI']<(data['FTI'].mean() + 3*data['FTI'].std())]

data = data[data['age'] <= 100]

"""    The diagnosis consists of a string of letters indicating diagnosed conditions. A diagnosis "-" indicates no condition requiring comment.  
    A diagnosis of the form "X|Y" is interpreted as "consistent with X, but more likely Y".  
    The conditions are divided into groups where each group corresponds to a class of comments.**

    Letter  Diagnosis
    ------  ---------

    hyperthyroid conditions:

    A   hyperthyroid
    B   T3 toxic
    C   toxic goitre
    D   secondary toxic

    hypothyroid conditions:

    E   hypothyroid
    F   primary hypothyroid
    G   compensated hypothyroid
    H   secondary hypothyroid

    binding protein:

    I   increased binding protein
    J   decreased binding protein

    general health:

    K   concurrent non-thyroidal illness

    replacement therapy:

    L   consistent with replacement therapy
    M   underreplaced
    N   overreplaced

    antithyroid treatment:

    O   antithyroid drugs
    P   I131 treatment
    Q   surgery

    miscellaneous:

    R   discordant assay results
    S   elevated TBG
    T   elevated thyroid hormones

"""

data['target'].unique()

# mapping for target variable
map = {'-':"Negative",'A':'Hyperthyroid','AK':"Hyperthyroid", 'B':"Hyperthyroid",
           'C':"Hyperthyroid", 'C|I': 'Hyperthyroid', 'D':"Hyperthyroid",
           'D|R':"Hyperthyroid", 'E': "Hypothyroid",'F': "Hypothyroid",
           'FK': "Hypothyroid", "G": "Hypothyroid", "GK": "Hypothyroid",
           "GI": "Hypothyroid", 'GKJ': 'Hypothyroid', 'H|K': 'Hypothyroid',
          }

data['target'] = data['target'].map(map)
data.dropna(subset=['target'], inplace=True)

data['target'].unique()

data.dropna()

"""#### **Data Visualization üé®**

In visualizing the Thyroid Detection dataset, the age distribution reveals a diverse range of patient ages, offering insights into the demographic composition. Examination of gender distribution demonstrates the representation of males and females. A focus on the target variable exposes the prevalence of hyperthyroidism, guiding subsequent analysis. Exploration of laboratory test results and binary feature distributions provides a nuanced understanding of thyroid-related conditions. These visualizations collectively enhance data comprehension and inform subsequent machine learning model development.
"""

# Plotting For Gender

labels = ['Female', 'Male']
plt.figure(figsize=(15,5))

plt.subplot(1, 2, 1)
sns.countplot(data=data, x='sex', hue='sex', alpha=1)
plt.legend(labels)
plt.title('Histogram For Gender',size=15)

plt.subplot(1, 2, 2)
female, male = data['sex'].value_counts()
y = [female, male]
explode = [0, 0.0]
labels = ['Female', 'Male']
plt.pie(y, labels=labels, explode=explode,autopct='%.2f%%')
plt.axis('equal')
plt.legend(labels)
circle = plt.Circle(xy=(0, 0), radius=0.75, facecolor='White', edgecolor='black')
plt.gca().add_artist(circle)
plt.title('Pie Chart for Gender', size=15)
plt.show()

"""- The histogram and pie chart illustrate that 66.42% of the data corresponds to females, while males account for 33.58%. This suggests that the dataset contains a higher proportion of females compared to males."""

plt.figure(figsize=(15,7))
sns.histplot(data['age'],kde=False,color='skyblue')
plt.title('Histogram For Age', size=15)
plt.show()

"""- The histogram reveals a concentration of individuals aged 20 to 80, peaking between 58 to 62 years. A decline is evident in the 1 to 15 age range, suggesting lower frequency. The x-axis denotes age groups, and the y-axis signifies the corresponding number of people. The distribution is relatively even, with a peak in the 21-30 age range, and fewer individuals in both younger and older age categories."""

data['target'].value_counts()

# Plotting For Gender

labels = ['Female','Male']
plt.figure(figsize=(15,5))

plt.subplot(1, 2, 1)
sns.countplot(data=data, x='target', hue='sex', alpha=1)
plt.legend(labels)
plt.title('Histogram For Gender Vs Disease',size=15)

plt.subplot(1, 2, 2)
Negative,Hypothyroid,Hyperthyroid = data['target'].value_counts()
y = [Negative,Hypothyroid,Hyperthyroid]
explode = [0, 0.0,0]
labels = ['Negative', 'Hypothyroid','Hyperthyroid']
plt.pie(y, labels=labels, explode=explode,autopct='%.2f%%')
plt.axis('equal')
plt.legend(labels)
circle = plt.Circle(xy=(0, 0), radius=0.75, facecolor='White', edgecolor='black')
plt.gca().add_artist(circle)
plt.title('Pie Chart for Disease', size=15)
plt.show()

"""- The histogram displays gender-specific prevalence across disease types, indicating a higher occurrence in females. Hypothyroidism is the most prevalent, followed by Hyperthyroidism. The majority fall into the "Negative" category, signifying a lack of the depicted diseases.

- The pie chart emphasizes the prevalence of the "Negative" category at 90.89%, with Hyperthyroidism and Hypothyroidism accounting for 7.68% and 1.43%, respectively.
"""

# Stacked Histogram
plt.figure(figsize=(15,5))

# Subplot 1
plt.subplot(1, 2, 1)
sns.histplot(data=data, x="age", hue="sex", multiple="stack", kde=True)
plt.title('Stacked Histogram for Age by Sex')

# Subplot 2
plt.subplot(1, 2, 2)
sns.histplot(data=data, x="age", hue="target", multiple="stack", kde=True)
plt.title('Stacked Histogram for Age by Target')

plt.show()

"""**Stacked Histogram for Age by Sex**
- the bar for the 20-30 age group shows that there are about 200 females and 100 males in that age group. The histogram shows that there are more females than males in all age groups except for the 0-10 age group. There are also more females than males in the younger age groups (20-30 and 30-40), but the difference is smaller in the older age groups

**Stacked Histogram for Age by Target**
- the bar for the 20-30 age group shows that there are about 100 people in the blue target group, 50 people in the green target group, and 25 people in the orange target group. The histogram shows that the distribution of people by target varies across different age groups. For example, the blue target group is more common in the younger age groups (20-30 and 30-40), while the green target group is more common in the older age groups (50-60 and 60-70).
"""

plt.figure(figsize=(13, 5))

# Subplot 1
plt.subplot(1, 2, 1)
sns.violinplot(data=data, x="target", y="age", hue="sex", split=True, bw=.2, inner="quart", palette="muted")
plt.title('Violin Plot: Gender vs Disease', size=15)

# Subplot 2
plt.subplot(1, 2, 2)
sns.violinplot(data=data, x="sick", y="age", hue="sex", split=True, bw=.2, inner="quart", palette="muted")
plt.title('Violin Plot: Gender vs Disease', size=15)

plt.tight_layout()
plt.show()

"""**Violin Plot: Gender vs Disease**

- violin for females with Hypothyroidism shows a wider body and longer tails compared to the violin for males with the same disease. This indicates that there are more females with Hypothyroidism overall, and their disease severity is more spread out compared to males. Overall, the chart suggests that more females than males have each disease, and the distribution of disease severity appears to differ between genders.

**Violin Plot: Age vs Disease**

- violin for the "Negative" category in the 20-30 age group shows a wider body compared to the same category in the 60-70 age group. This suggests that there are more people who are disease-free in the younger age group. Overall, the chart seems to indicate that the distribution of diseases varies across different age groups.
"""

plt.figure(figsize=(15,15))
sns.set(style='whitegrid')


plt.subplot(3, 2, 1)
sns.histplot(data['age'], kde=True, color='blue', edgecolor='black',alpha=0.2)
plt.title('Age Of The Patient', color='black', fontsize=20)
plt.xlabel('Age')
plt.ylabel('Frequency')

plt.subplot(3, 2, 2)
sns.histplot(data['T3'], kde=True, color='green', edgecolor='black',alpha=0.2)
plt.title('T3 level in blood', color='black', fontsize=20)
plt.xlabel('T3')
plt.ylabel('Frequency')

plt.subplot(3, 2, 3)
sns.histplot(data['TT4'], kde=True, color='red', edgecolor='black',alpha=0.2)
plt.title('TT4 level in blood', color='black', fontsize=20)
plt.xlabel('TT4')
plt.ylabel('Frequency')

plt.subplot(3, 2, 4)
sns.histplot(data['T4U'], kde=True, color='black', edgecolor='black',alpha=0.2)
plt.title('T4U level in blood', color='black', fontsize=20)
plt.xlabel('T4U')
plt.ylabel('Frequency')

plt.subplot(3, 2, 5)
sns.histplot(data['TSH'], kde=True, color='blue', edgecolor='black',alpha=0.2)
plt.title('TSH level in blood ', color='black', fontsize=20)
plt.xlabel('TSH')
plt.ylabel('Frequency')

plt.subplot(3, 2, 6)
sns.histplot(data['FTI'], kde=True, color='green', edgecolor='black',alpha=0.2)
plt.title('FTI level in blood', color='black', fontsize=20)
plt.xlabel('FTI')
plt.ylabel('Frequency')



plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

columns_to_plot = ['TSH', 'FTI', 'T4U', 'TT4']

plt.figure(figsize=(15, 10))

light_colors = ['lightcoral', 'lightgreen', 'lightblue', 'thistle']

for i, (column, color) in enumerate(zip(columns_to_plot, light_colors), start=1):
    plt.subplot(2, 2, i)
    plt.scatter(data['age'], data[column], label=f'Age vs {column}', color=color, edgecolors='black', linewidth=1, alpha=0.5)
    plt.xlabel('Age')
    plt.ylabel(column)
    plt.title(f'Scatter Plot: Age vs {column}', color='black', fontsize=20)
    plt.legend()
plt.tight_layout()

plt.show()

"""**Age vs TSH:**
- Weak positive correlation observed between age and TSH levels. Older individuals tend to have slightly higher TSH levels, but there's significant variability.

**Age vs FTI:**
- No clear correlation between age and FTI levels. No consistent trend in how FTI levels change with age.

**Age vs T4U:**
- Weak negative correlation between age and T4U levels. Older individuals tend to have slightly lower T4U levels, but there's significant variability.

**Age vs TT4:**
- Weak negative correlation between age and TT4 levels. Older individuals tend to have slightly lower TT4 levels, but there's significant variability.
"""

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(15, 10))
sns.set(style='whitegrid')

plt.subplot(2, 2, 1)
sns.kdeplot(data=data, x="TSH", hue="sex", multiple="stack", fill=True)
plt.title("Density Of TSH Vs Sex", fontsize=15, color='black')
plt.legend(title='Sex', labels=['Male', 'Female'])

plt.subplot(2, 2, 2)
sns.kdeplot(data=data, x='FTI', hue="sex", multiple="stack", fill=True)
plt.title("Density Of FTI Vs Sex", fontsize=15, color='black')
plt.legend(title='Sex', labels=['Male', 'Female'])

plt.subplot(2, 2, 3)
sns.kdeplot(data=data, x='T4U', hue="sex", multiple="stack", fill=True)
plt.title("Density Of T4U Vs Sex", fontsize=20, color='black')
plt.legend(title='Sex', labels=['Male', 'Female'])

plt.subplot(2, 2, 4)
sns.kdeplot(data=data, x="TT4", hue="sex", multiple="stack", fill=True)
plt.title("Density Of TT4 Vs Sex", fontsize=15, color='black')
plt.legend(title='Sex', labels=['Male', 'Female'])

plt.tight_layout()
plt.show()

"""- The first chart shows the density of TSH (thyroid-stimulating hormone) versus sex. The x-axis shows the TSH level, and the y-axis shows the density. The chart is divided into two colors, blue for males and pink for females. The chart shows that TSH levels are higher in females than in males.

- The second chart shows the density of FTI (free thyroxine index) versus sex. The x-axis shows the FTI level, and the y-axis shows the density. The chart is divided into two colors, blue for males and pink for females. The chart shows that FTI levels are higher in females than in males.

- The third chart shows the density of T4U (total thyroxine uptake) versus sex. The x-axis shows the T4U level, and the y-axis shows the density. The chart is divided into two colors, blue for males and pink for females. The chart shows that T4U levels are higher in females than in males.

- The fourth chart shows the density of TT4 (total thyroxine) versus sex. The x-axis shows the TT4 level, and the y-axis shows the density. The chart is divided into two colors, blue for males and pink for females. The chart shows that TT4 levels are higher in females than in males.
"""

import seaborn as sns
import matplotlib.pyplot as plt

# Assuming 'data' is your DataFrame
female_data = data[data['sex'] == 'F']

fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(12, 6))

# Count plot on the left side
sns.countplot(x='pregnant', data=female_data, palette='muted', ax=axes[0])
axes[0].set_title('Count Plot of Pregnant for Females',color='black')
for p in axes[0].patches:
    axes[0].annotate(f'{p.get_height()}', (p.get_x() + p.get_width() / 2., p.get_height()),
        ha='center', va='center', xytext=(0, 10), textcoords='offset points', color='black')

# Pie chart on the right side
pregnant_counts = female_data['pregnant'].value_counts()
axes[1].pie(pregnant_counts, labels=pregnant_counts.index, autopct='%1.1f%%', colors=sns.color_palette('muted'), startangle=90)
axes[1].set_title('Pie Chart of Pregnant Distribution\nNumber of Females: {}'.format(len(female_data)),color='black')

plt.tight_layout()
plt.show()

"""- First charts say that pregnant women are too less. Out of 4778 only 30 noumber of women is pregnet but this data is important for our model. Because we know that measure thyriod  impact
Sceen in women only.

- Second pie chart shows that 0.6 percenatge of women are pragment out of 100 percent.

"""

import plotly.express as px
fig1 = px.scatter(data, x='age', y='T3', color='target', color_discrete_map={'Hypothyroid': '#4b9546', 'Hyperthyroid': '#F65366', 'Negative': '#3498db'})

fig1.show()

fig1 = px.scatter(data, x='age', y='FTI', color='target', color_discrete_map={'Hypothyroid': '#4b9546', 'Hyperthyroid': '#F65366', 'Negative': '#3498db'})
fig1.show()

fig1 = px.scatter(data, x='age', y='T4U', color='target', color_discrete_map={'Hypothyroid': '#4b9546', 'Hyperthyroid': '#F65366', 'Negative': '#3498db'})
fig1.show()

fig1 = px.scatter(data, x='age', y='TT4', color='target', color_discrete_map={'Hypothyroid': '#4b9546', 'Hyperthyroid': '#F65366', 'Negative': '#3498db'})

fig1.show()

import plotly.express as px

# Assuming data is your DataFrame
fig = px.scatter_3d(data, x='T4U', y='T3', z='TSH', color='target',
                    color_discrete_map={'Hypothyroid': '#4b9546', 'Hyperthyroid': '#F65366', 'Negative': '#3498db'},
                    size='age', opacity=0.7, hover_data=['age', 'target'])

# Set the layout to make it full page
fig.update_layout(width=800, height=800)

# Show the plot
fig.show()

"""This 3D chart illustrates three distinct clusters representing hyperthyroid, hypothyroid, and negative thyroid conditions, each occupying its own space. It aids in comprehending the three-dimensional distribution of the blood sample data."""

fig4 = px.violin(data, x='sex', y='age', color='target', points='all', facet_col='target', height=700,
                color_discrete_map={'Hypothyroid': '#4b9546', 'Hyperthyroid': '#F65366', 'Negative': '#3498db'})
fig4.show()

import seaborn as sns
import matplotlib.pyplot as plt

# Assuming 'data' is your DataFrame containing numerical and categorical columns including 'target'
sns.set_style('darkgrid')

# Replace 'data' with your actual DataFrame
selected_columns = data.select_dtypes(include=['number']).columns.tolist() + ['target']
sns.pairplot(data[selected_columns], hue='target')

plt.show()

"""In these charts, we observe that all the blood sample data form distinct clusters representing different thyroid conditions. This comprehensive sample space enhances predictive accuracy."""

plt.figure(figsize=(12,8))
sns.heatmap(data.select_dtypes(include=['number']).corr(),annot=True,cmap='coolwarm')
plt.title("Correlation",fontsize=20)
plt.show()

"""- **Age:** Age has a weak negative correlation with TSH and T3, and a weak positive correlation with TT4, T4U, and FTI. This means that as people age, their TSH and T3 levels tend to decrease, while their TT4, T4U, and FTI levels tend to increase.
- **TSH:** TSH has a strong negative correlation with T3, TT4, T4U, and FTI. This means that when TSH levels are high, the levels of other thyroid hormones tend to be low, and vice versa. This is because TSH stimulates the production of T3 and T4 by the thyroid gland.
- **T3:** T3 has a strong positive correlation with TT4 and T4U, and a moderate positive correlation with FTI. This means that T3 levels tend to be higher when TT4, T4U, and FTI levels are also higher.
- **TT4:** TT4 has a strong positive correlation with T4U and FTI. This means that TT4 levels tend to be higher when T4U and FTI levels are also higher.
"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

data_encoded = pd.get_dummies(data)

# Create a correlation matrix
correlation_matrix = data_encoded.corr()

# Plot the heatmap
plt.figure(figsize=(12, 8))
sns.heatmap(correlation_matrix, annot=False, cmap='coolwarm')
plt.title("Correlation", fontsize=20)
plt.show()

"""**Age:**
- Age has a weak negative correlation with T3 and T4U, and a weak positive correlation with TT4 and FTI. This means that as people age, their T3 and T4U levels tend to decrease, while their TT4 and FTI levels tend to increase.

**Sex:**
- Female sex has a negative correlation with TSH and a positive correlation with FT4. This means that women tend to have lower TSH levels and higher FT4 levels than men.

**Thyroid medication:**
- Being on thyroxine therapy (on_thyroxine_f) has a strong negative correlation with TSH, T3, and FT4. This is expected, as thyroxine medication suppresses the production of TSH and increases thyroid hormone levels. Being on antithyroid medication (on_antithyroid_meds_f) has a positive correlation with TSH and a negative correlation with FT4. This is also expected, as antithyroid medication blocks the production of thyroid hormones and increases TSH levels.

**Other medical conditions:**
- Several other medical conditions are shown to have correlations with thyroid hormone levels. For example, pregnancy (pregnant_f) is associated with higher T4 levels, while hypothyroidism (target_Hypothyroid) is associated with lower T4 levels and higher TSH levels.
"""

plt.figure(figsize=(15, 10))
sns.set(style='whitegrid')

plt.subplot(2, 2, 1)
sns.boxplot(data=data, y="TSH", color='skyblue')
plt.title("Boxplot of TSH", fontsize=15, color='black')

plt.subplot(2, 2, 2)
sns.boxplot(data=data, y='FTI', color='salmon')
plt.title("Boxplot of FTI", fontsize=15, color='black')

plt.subplot(2, 2, 3)
sns.boxplot(data=data, y='T4U', color='lightgreen')
plt.title("Boxplot of T4U", fontsize=15, color='black')

plt.subplot(2, 2, 4)
sns.boxplot(data=data, y="TT4", color='lightcoral')
plt.title("Boxplot of TT4", fontsize=15, color='black')

plt.tight_layout()
plt.show()

"""**TSH:**
-  The median TSH level is much lower in the euthyroid group compared to the hyperthyroid group. This is expected, as TSH levels are typically suppressed in people with hyperthyroidism.

**FTI, T4U, and TT4:**
- The median levels of FTI, T4U, and TT4 are all higher in the hyperthyroid group compared to the euthyroid group. This is also expected, as these thyroid hormone levels are elevated in people with hyperthyroidism.

**Spread of data:**
- The boxplots also show that there is more spread in the data in the hyperthyroid group compared to the euthyroid group for all four thyroid hormone levels. This suggests that there is more variability in thyroid hormone levels in people with hyperthyroidism.
"""

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(15, 10))
sns.set(style='whitegrid')

plt.subplot(3, 2, 1)
sns.kdeplot(data=data, x="T3", color='skyblue', fill=True)
plt.title("Density Plot of T3", fontsize=15, color='black')

plt.subplot(3, 2, 2)
sns.kdeplot(data=data, x='FTI', color='salmon', fill=True)
plt.title("Density Plot of FTI", fontsize=15, color='black')

plt.subplot(3, 2, 3)
sns.kdeplot(data=data, x='T4U', color='lightgreen', fill=True)
plt.title("Density Plot of T4U", fontsize=15, color='black')

plt.subplot(3, 2, 4)
sns.kdeplot(data=data, x="TT4", color='lightcoral', fill=True)
plt.title("Density Plot of TT4", fontsize=15, color='black')

plt.subplot(3, 2, 5)
sns.kdeplot(data=data, x='TSH', color='lightgreen', fill=True)
plt.title("Density Plot of TSH", fontsize=15, color='black')

plt.subplot(3, 2, 6)
sns.kdeplot(data=data, x="age", color='lightcoral', fill=True)
plt.title("Density Plot of AGE", fontsize=15, color='black')
plt.tight_layout()

plt.show()

"""### **Convert Categorical To Numerical Data And Drop Unnecessary Columns üßÆ**
- transforming categorical data into numerical format for enhanced analysis. Utilize techniques like one-hot encoding or label encoding to convert categorical variables into numerical representations, ensuring compatibility with machine learning algorithms.

**Drop Unnecessary Columns**
"""

selected_columns = ['age','sex', 'TT4', 'T3', 'T4U', 'FTI', 'TSH', 'pregnant', 'target']
data = data[selected_columns]

data.head(10)

"""**Convert Categorical data to numerical**"""

from sklearn.preprocessing import LabelEncoder
le = LabelEncoder()
data['target']=le.fit_transform(data['target'])
data['sex']=le.fit_transform(data['sex'])
data['pregnant']=le.fit_transform(data['pregnant'])
data.head(10)

print('Size of data frame after convert numeric data set :',data.shape)
print('Rows :',data.shape[0])
print('Columns :',data.shape[1])

"""#### **Training And Testing Sets For Machine Learning**"""

y = data[['target']] # Depended
x = data[['age','sex', 'TT4', 'T3', 'T4U', 'FTI', 'TSH', 'pregnant']] # independent

y.value_counts()

y.head(5)

import plotly.express as px

# Assuming data is your DataFrame
fig = px.scatter_3d(data, x='T4U', y='T3', z='TSH', color='target',
                    color_discrete_map={'Hypothyroid': '#4b9546', 'Hyperthyroid': '#F65366', 'Negative': '#3498db'},
                    size='age', opacity=0.7, hover_data=['age', 'target'])

# Set the layout to make it full page
fig.update_layout(width=800, height=800)

# Show the plot
fig.show()

"""- **Split data into Training and Testing**"""

from sklearn.model_selection import train_test_split,GridSearchCV
x_train,x_test,y_train,y_test = train_test_split(x,y,test_size=0.3,random_state=1)

y.value_counts()

print('Length of Training Set :',len(x_train))
print('Length of Testing Set :',len(x_test))

"""#### **Model Execution:**

- Based on the boxplot, there are many outliers in the dataset, so we choose the non-parametric machine learning model, which is KNN.

**KNN (K- Neighrest Neighbour Classifier)**
- KNN (K-Nearest Neighbors) Classifier is a versatile and intuitive machine learning algorithm commonly employed in thyroid detection. It operates by classifying data points based on the majority class of their k-nearest neighbors in the feature space. With its simplicity and effectiveness in handling non-linear relationships, KNN proves valuable in identifying patterns and making accurate predictions for thyroid detection in your project.
"""

from sklearn.neighbors import KNeighborsClassifier

knn = KNeighborsClassifier(n_neighbors=3)
knn.fit(x_train,y_train)

!pip install catboost

from catboost import CatBoostClassifier

param_grid = {'n_estimators': [100,200,250,300,350,400,500]}
model = CatBoostClassifier(random_state=42)
grid_search = GridSearchCV(model,param_grid,cv=5,scoring='accuracy')
grid_search.fit(x_train,y_train,verbose=False)
print('grid search reasult:')
print('best parameters : ', grid_search.best_params_)
print('best cross-validated accuracy: ',grid_search.best_score_)

from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score

model_cat = CatBoostClassifier(n_estimators=300, random_state=42, verbose=False)

model_cat.fit(x_train, y_train)

y_pred = model_cat.predict(x_test)
accuracy = accuracy_score(y_test, y_pred)
precision = precision_score(y_test, y_pred, average='macro')
recall = recall_score(y_test, y_pred, average='macro')
f1 = f1_score(y_test, y_pred, average='macro')
score = model_cat.score(x_train,y_train)

print(f'Accuracy :  {accuracy:.2f}%')
print(f'Precision :  {precision:.2f}%')
print(f'Recall :  {recall:.2f}%')
print(f'F1 score :  {f1:.2f}%')
print(f'score :  {score:.2f}%')

from xgboost import XGBClassifier

param_grid = {'n_estimators': [100,200,250,300,350,400,500]}
model = XGBClassifier(random_state=42)
grid_search = GridSearchCV(model,param_grid,cv=5,scoring='accuracy')
grid_search.fit(x_train,y_train,verbose=False)
print('grid search reasult:')
print('best parameters : ', grid_search.best_params_)
print('best cross-validated accuracy: ',grid_search.best_score_)

model_xgb = XGBClassifier(n_estimators=500, random_state=42, verbose=False)

model_xgb.fit(x_train, y_train)

y_pred = model_xgb.predict(x_test)
accuracy = accuracy_score(y_test, y_pred)
precision = precision_score(y_test, y_pred, average='macro')
recall = recall_score(y_test, y_pred, average='macro')
f1 = f1_score(y_test, y_pred, average='macro')
score = model_xgb.score(x_train,y_train)

print(f'Accuracy :  {accuracy:.2f}%')
print(f'Precision :  {precision:.2f}%')
print(f'Recall :  {recall:.2f}%')
print(f'F1 score :  {f1:.2f}%')
print(f'score :  {score:.2f}%')

knn.score(x_test,y_test)

from sklearn.metrics import mean_squared_error

#Predicted On The Test Set
y_pred= model_cat.predict(x_test)

# Evaluate The Model
Training_score  = model_cat.score(x_train,y_train)
Testing_score  = model_cat.score(x_test,y_test)

mse = mean_squared_error(y_test,y_pred)
rmse = np.sqrt(mse)

from sklearn.metrics import r2_score

# Calculate R-squared
r2 = r2_score(y_test, y_pred)

# Calculate Adjusted R-squared
n = len(y_test)
p = x_test.shape[1]
adj_r2 = 1 - ((1 - r2) * (n - 1) / (n - p - 1))

print('Training Score :', Training_score, '%')
print('Testing Score :', Testing_score, '%')
print('Mean Squared Error (MSE) :', mse)
print('Root Mean Squared Error (RMSE) :', rmse)
print('R-squared (R2) :', r2)
print('Adjusted R-squared :', adj_r2)

from sklearn.metrics import mean_squared_error

#Predicted On The Test Set
y_pred= model_xgb.predict(x_test)

# Evaluate The Model
Training_score  = model_xgb.score(x_train,y_train)
Testing_score  = model_xgb.score(x_test,y_test)

mse = mean_squared_error(y_test,y_pred)
rmse = np.sqrt(mse)

from sklearn.metrics import r2_score

# Calculate R-squared
r2 = r2_score(y_test, y_pred)

# Calculate Adjusted R-squared
n = len(y_test)
p = x_test.shape[1]
adj_r2 = 1 - ((1 - r2) * (n - 1) / (n - p - 1))

print('Training Score :', Training_score, '%')
print('Testing Score :', Testing_score, '%')
print('Mean Squared Error (MSE) :', mse)
print('Root Mean Squared Error (RMSE) :', rmse)
print('R-squared (R2) :', r2)
print('Adjusted R-squared :', adj_r2)

r = knn.predict(x_test)
r[1]

"""#### **Result :**
- The training score of 96.4% indicates that the model is fitting the training data effectively.
- The testing score of 94.3% suggests a high level of accuracy on unseen data, demonstrating the model's generalization capability.
- The Mean Squared Error (MSE) of 0.080 and Root Mean Squared Error (RMSE) of 0.2840 are relatively low, indicating minimal prediction errors and a good overall model fit.
- These results collectively indicate a robust and well-performing thyroid detection model.

## **Confusion Metrix Visual**
The confusion matrix is an essential tool for assessing the effectiveness of a classification model. It offers a detailed breakdown of predictions, distinguishing between true positives, true negatives, false positives, and false negatives. This breakdown provides valuable insights into the precision, recall, and overall accuracy of the model. By visually representing the alignment between predicted and actual classes, confusion matrices aid in refining models and pinpointing areas for enhancement in machine learning endeavors.
"""

# Confusion Matrix
from sklearn.metrics import confusion_matrix,classification_report
cm = confusion_matrix(y_test,y_pred)

# confusion metric visual
import seaborn as sn
plt.figure(figsize=(7,5))
cm_df = pd.DataFrame(cm,
                     index = ['Hyperthyroid','Hypothyroid','Negative'],
                     columns = ['Hyperthyroid','Hypothyroid','Negative'])
sn.heatmap(cm_df,annot=True)

plt.xlabel('Predicted',color='black',size=15)
plt.ylabel('Truth',color='black',size=15)
plt.show()

"""**In this confusion matrix:**

- For class 0 (Hyperthyroid)
- For class 1 (Hypothyroid)
- For class 2 (Negative)

>	The model seems to perform well at classifying the hypothyroid condition, with a high number of correct predictions (93) and relatively low incorrect predictions (28 as negative and 11 as hyperthyroid).

>	The model struggles more with the hyperthyroid condition, with a higher number of incorrect predictions (87 as negative) compared to correct predictions (15).

>	 There seems to be a class imbalance, with a much higher number of negative cases compared to hyperthyroid and hypothyroid cases
"""

from sklearn.tree import DecisionTreeClassifier
from sklearn.svm import SVC
import matplotlib.pyplot as plt
from sklearn.metrics import f1_score, precision_score, recall_score, accuracy_score

# Initialize KNN with 5 neighbors
from sklearn.neighbors import KNeighborsClassifier
knn = KNeighborsClassifier(n_neighbors=5)
xgb = XGBClassifier(n_estimators=500, random_state=42, verbose=False)
cat = CatBoostClassifier(n_estimators=300, random_state=42, verbose=False)

# Initialize classifiers
classifiers = {
    "KNN": knn,
    "xgboost": xgb,
    "catboost": cat
}

# Evaluate other classifiers
for name, clf in classifiers.items():
    clf.fit(x_train, y_train)
    y_pred = clf.predict(x_test)
    training_score = clf.score(x_train, y_train)
    testing_score = clf.score(x_test, y_test)
    f1 = f1_score(y_test, y_pred, average='weighted')
    precision = precision_score(y_test, y_pred, average='weighted')
    recall = recall_score(y_test, y_pred, average='weighted')
    accuracy = accuracy_score(y_test, y_pred)
    print(f"{name}:")
    print("Training Score:", training_score)
    print("Testing Score:", testing_score)
    print("F1 Score:", f1)
    print("Precision:", precision)
    print("Recall:", recall)
    print("Accuracy:", accuracy)
    print()

# Accuracy comparison graph
accuracies = [clf.score(x_test, y_test) for clf in classifiers.values()]
plt.figure(figsize=(10, 6))
plt.bar(classifiers.keys(), accuracies, color='skyblue')
plt.xlabel('Classifiers', fontsize=14)
plt.ylabel('Accuracy', fontsize=14)
plt.title('Accuracy Comparison of Classifiers', fontsize=16)
plt.ylim(0.7, 1.0)
plt.xticks(rotation=45)
plt.show()

"""The K-Nearest Neighbors (KNN) model achieved a training score of 0.954, with a testing score of 0.936. Its F1 score stands at 0.928, with precision and recall both at 0.929 and accuracy matching recall at 0.936. Despite its high overall performance, KNN exhibits a slight decrease in precision compared to the other models.

In contrast, the Decision Tree model attained a perfect training score of 1.0, with a testing score of 0.949. Its F1 score mirrors testing accuracy at 0.949, with precision and recall both at 0.950. This model showcases strong generalization ability despite the risk of overfitting to the training data, which is indicated by the perfect training score.

Lastly, the Support Vector Machine (SVM) model demonstrated a training score of 0.930, slightly lower than KNN and Decision Tree. Its testing score aligns closely with the training score at 0.928. The F1 score for SVM is 0.909, with precision and recall both at 0.928, matching the testing accuracy. SVMs are known for their effectiveness in handling complex datasets, and despite the slightly lower training score, this model performs robustly on the testing data.

### **Improve Model Accuracy (By Under-sampling Dataset)** :

We will again utilize the same models (KNN, Decision Tree, and SVC) with reduced sample data. Afterward, we will increase the entire dataset threefold to enhance clustering strength.

After balancing our data, we aim to demonstrate its effectiveness in creating a well-defined cluster space for all target variable numbers. We will proceed by applying all three models to this balanced dataset.

- **Split data into Training and Testing**

**KNN (K- Neighrest Neighbour Classifier) {under sampling)**
- KNN (K-Nearest Neighbors) Classifier is a versatile and intuitive machine learning algorithm commonly employed in thyroid detection. It operates by classifying data points based on the majority class of their k-nearest neighbors in the feature space. With its simplicity and effectiveness in handling non-linear relationships, KNN proves valuable in identifying patterns and making accurate predictions for thyroid detection in your project.
"""

r = xgb.predict(x_test)
r[1]

"""### **Confusion Matrix**"""

# Confusion Matrix
from sklearn.metrics import confusion_matrix,classification_report
cm = confusion_matrix(y_test,y_pred)

# confusion metric visual
import seaborn as sn
plt.figure(figsize=(7,5))
cm_df = pd.DataFrame(cm,
                     index = ['Hyperthyroid','Hypothyroid','Negative'],
                     columns = ['Hyperthyroid','Hypothyroid','Negative'])
sn.heatmap(cm_df,annot=True)

plt.xlabel('Predicted',color='black',size=15)
plt.ylabel('Truth',color='black',size=15)
plt.show()

from sklearn.metrics import classification_report

# Classification Report
print(classification_report(y_test, y_pred))

# Import necessary libraries
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout

# Prepare data
X = data[['age', 'sex', 'TT4', 'T3', 'T4U', 'FTI', 'TSH', 'pregnant']]
y = data['target']

# Split data into train and test sets
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# Normalize data
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# Convert labels to categorical
from tensorflow.keras.utils import to_categorical
y_train_cat = to_categorical(y_train)
y_test_cat = to_categorical(y_test)

# Define the model architecture
model = Sequential()
model.add(Dense(64, activation='relu', input_shape=(X_train.shape[1],)))
model.add(Dropout(0.1))
model.add(Dense(32, activation='relu'))
model.add(Dropout(0.1))
model.add(Dense(3, activation='softmax'))  # 3 output units for 3 classes

# Compile the model
model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

# Train the model
epochs = 100
batch_size = 32
model.fit(X_train, y_train_cat, epochs=epochs, batch_size=batch_size, validation_data=(X_test, y_test_cat))

# Evaluate the model on the test set
test_loss, test_accuracy = model.evaluate(X_test, y_test_cat)
print(f'Test Loss: {test_loss:.4f}')
print(f'Test Accuracy: {test_accuracy:.4f}')

import joblib

import pickle

# Save the trained model
with open('model.pkl', 'wb') as f:
    pickle.dump(model, f)

# Later, you can load the model using:
# with open('model.pkl', 'rb') as f:
#     loaded_model = pickle.load(f)


# Save the trained model in .h5 format
model.save('model.h5')

# Later, you can load the model using:
# loaded_model = tf.keras.models.load_model('model.h5')